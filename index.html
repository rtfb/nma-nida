<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Functional programming</title>

		<meta name="description" content="An introduction to functional programming">
		<meta name="author" content="Vytautas Šaltenis, Bentley Systems">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/white.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
    <section data-background="./img/title.png">
        <h1>Functional Programming</h1>
        <p>
        <small>Presented by <a href="http://rtfb.lt">Vytautas Šaltenis</a> / <a href="http://twitter.com/rtfb">@rtfb</a></small>
        </p>
    </section>

    <section data-background="./img/bg.png">
        <h2>Intro and agenda</h2>
        <p>
        Let's learn something.
        </p>
        <ul>
            <li>Conceptual intro</li>
            <li>Some examples in various lingos</li>
            <li>Motivation</li> <!-- TODO: add a whole section on it and list things there -->
            <li>Patterns</li>
            <li>More patterns</li>
            <li>Then a workshop</li>
        </ul>
    </section>

    <section data-background="./img/bg.png">
        <section>
            <h2>Let's see some Python code:</h2>
            <pre><code data-trim contenteditable>
def triplicate(lst):
    return map(lambda ch: ch*3, lst)

triplicate(['a', 'b', 'c'])
=> ['aaa', 'bbb', 'ccc']
            </code></pre>
        </section>
        <section>
            <h2>And now in JavaScript:</h2>
            <pre><code data-trim contenteditable>
function triplicate(arr) {
    return arr.map(function(item) {
        return item + item + item;
    });
}

triplicate(['a', 'b', 'c']);
=> ["aaa", "bbb", "ccc"]
            </code></pre>
        </section>
        <section>
            <h2>And in Lisp, just for the kicks :-)</h2>
            <pre><code data-trim contenteditable>
(defun triplicate (list)
  (mapcar (lambda (item)
            (concatenate 'string item item item))
          list))

(triplicate '("a" "b" "c"))
=> ("aaa", "bbb", "ccc")
            </code></pre>
        </section>
    </section>

    <section data-background="./img/bg.png">
        <!-- <h2>Conceptual intro</h2> -->
        <h3>What is functional programming?</h3>
        <h5>Random facts:</h5>
        <p>Based on lambda calculus, invented in 1930s (by Alonzo Church)</p>
        <p>First implemented in Lisp in 1958 (by John McCarthy)</p>
    </section>

    <section data-background="./img/bg.png">
        <!-- <h2>Conceptual intro</h2> -->
        <h3>What is functional programming?</h3>
        <h5>Intuitive explanation:</h5>
        <p>Break down your problem in such a way that it could be solved by
           functions and functions only. Like this:</p>
        <pre><code data-trim contenteditable>
f(g(h(i(initial_data))))
=> final_result
        </code></pre>
        <p>No ifs, no loops, no variables, no nothing. Just functions.</p>
    </section>

    <section data-background="./img/bg.png">
        <h3>Purity</h3>
        <p>...but most importantly, no side effects!</p>
        <p>Every function should be mathematically pure, taking parameters and
        producing its output independently from anything else in the world.</p>
    </section>

    <section data-background="./img/bg.png">
        <h3>Full purity is impossible</h3>
        <p>Because I/O is also a side effect!</p>
        <!--
            So a purely pure program can only compute, it can't display it's
            results, which is not terribly useful :-)
        -->
    </section>

    <section data-background="./img/bg.png">
        <!-- <h2>Motivation</h2> -->
        <h3>Why bother?</h3>
        <p>Parallelism!</p>
        <p>Abstractions</p>
        <p>Formal provability</p>
        <p>Modularity</p>
        <p>Composability</p>
        <p>Lazy evaluation</p>
        <p>Unix</p>
    </section>

    <section data-background="./img/bg.png">
        <h3>Parallelism</h3>
        <p>Modern GPU can run 3000 threads <strong>at once!</strong></p>
        <p>Modern server farm can do much more</p>
        <p>Yes, you <strong>will</strong> use server farms, most likely on the cloud</p>
        <p>And it's pretty much impossible to program one of the above w/o functional approach</p>
    </section>

    <section data-background="./img/bg.png">
        <h3>Abstractions</h3>
        <section>
            <pre><code data-trim contenteditable>
vector&lt;string&gt; vs{"a", "b", "c"};
for (vector&lt;string&gt;::iterator it = vs.begin(); it != vs.end(); ++it) {
    do_something_with(*it + *it + *it);
}
            </code></pre>
        </section>
        <section>
            <pre><code data-trim contenteditable>
vector&lt;string&gt; vs{"a", "b", "c"};
for (auto &s : vs) {
    do_something_with(s + s + s);
}
            </code></pre>
        </section>
    </section>

    <section data-background="./img/bg.png">
        <h3>Formal provability</h3>
        <p>The idea is to generate a formal proof with help of invariants.</p>
        <p>Works for other programming styles as well, but FP makes it easier</p>
        <p>Not that practical as some researchers would like us believe :-)</p>
    </section>

    <section data-background="./img/bg.png">
        <h3>Modularity</h3>
        <p>Since FP puts some draconian constraints, it becomes necessary to
        break down things into smaller pieces. And smaller pieces are better
        pieces.</p>
    </section>

    <section data-background="./img/bg.png">
        <h3>Composability</h3>
        <p>Remember?</p>
        <pre><code data-trim contenteditable>
f(g(h(i(initial_data))))
=> final_result
        </code></pre>
        <p>This is more useful than it seems at first glance, since you can then
        recompose functions from other places. You can do that with other code,
        too, but FP makes it easer as long as you have uniform data
        structures.</p>
    </section>

    <section data-background="./img/bg.png">
        <h3>Lazy evaluation</h3>
        <p>Infinite data structures, generators and such...</p>
        <p>Found in Python, C#, F#, Haskell elsewhere.</p>
    </section>

    <section data-background="./img/bg.png">
        <section>
        <h3>Unix</h3>
            <pre><code data-trim contenteditable>
tr 'A-Z' 'a-z' < ~/shakespeare.txt | tr -sc 'A-Za-z' '\n' | \
    sort | uniq -c | sort -n -r | head
            </code></pre>
        </section>
        <section>
            <pre><code data-trim contenteditable>
$ tr 'A-Z' 'a-z' < ~/shakespeare.txt | tr -sc 'A-Za-z' '\n' | sort | uniq -c | sort -n -r | head
  27843 the
  26847 and
  22538 i
  19882 to
  18307 of
  14800 a
  13928 you
  12490 my
  11563 that
  11183 in
            </code></pre>
        </section>
    </section>

    <section data-background="./img/bg.png">
        <!-- <h2>Patterns</h2> -->
        <h3>Patterns/algorithms</h3>
        <p>Map</p>
        <p>Filter</p>
        <p>Zip</p>
        <p>Gather</p>
        <p>Scatter</p>
        <p>Transpose</p>
        <p>Reduce</p>
        <p>Scan</p>
        <p>Histogram</p>
    </section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
